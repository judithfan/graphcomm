var speakerModel = function(targetObj, context, params, config) {

  // For now ignore cost
  var sketchCost = function(sketch) {
    return config.costs[sketch];
  };

  var similarity = function(sketch, object) {
    return (config.similarities[params.perception][object][sketch] + 1.001)/2;
  };

  // Sees sketch and selects among objects in context using similarity
  var literalListener = function(sketch, context){
    return Infer({method:'enumerate', model: function(){
      var object = uniformDraw(context);
      factor(params.simScaling * similarity(sketch, object));
      return object;
    }});
  };

  // Note that informativities are always logs of the thing we care about
  // so that with alpha = 1, you produce sketches directly proportional
  // to their informativity (because factor adds to log space)
  var informativity = function(sketch) {
    var model = (params.pragmatics === 'combined' ?
		 (flip(params.pragWeight) ? 'S1 ' : 'S0') :
		 params.pragmatics);
    if(model === 'S1') {
      return refModule.getL0score(targetObj, sketch, context, params, config);
    } else if (model === 'S0') {
      return similarity(sketch, targetObj);
    } else {
      console.error('unknown pragmatics model:' + params.pragmatics);
    }
  };

  // Selects among sketches given raw similarity to target (ignoring context)
  var speaker = function(targetObj, context) {
    var similarities = config.similarities[params.perception];
    return Infer({method:'enumerate', model: function(){
      var sketch = uniformDraw(config.possibleSketches);
      // faster helper function for literalListener(sketch, context).score(targetObj) :
      var inf = informativity(sketch);
      var utility = (1 - sketchCost(sketch)) * inf - params.costWeight * sketchCost(sketch);
      factor(params.alpha * utility);
      return globalConfig.aggregate ? config.conditionLookup[sketch] : sketch;
    }});
  };

  return speaker(targetObj, context);
};
